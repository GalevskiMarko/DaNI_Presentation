
\documentclass[12pt]{article}
  \usepackage[a4paper, portrait, margin=1in]{geometry}
  \usepackage{amsmath, graphicx, gensymb, float, verbatim, tikz}
	\usepackage{amssymb}
  \newcommand\norm[1]{\left\lVert#1\right\rVert}
  \renewcommand{\vec}[1]{\mathbf{#1}}
	\usepackage{chngcntr}
	\counterwithin{figure}{section}
	\graphicspath{{./images/}}
	\usepackage[utf8]{inputenc}
	\usepackage{textcomp}
	\usepackage{multirow}
  \usepackage{listings}
  \usepackage[english, macedonian]{babel}
	\usepackage{biblatex}
	\addbibresource{sample.bib}


\title{ДИПЛОМСКА РАБОТА\bigbreak \textbf{Препознавање на човек преку фузија на сензори и машинско учење и неговото следење
				преку управување на DaNI робот со LabVIEW}}
  \date{10.3.18}
  \author{Галевски Марко 1172, Мучев Никола 1017	\\	Ментор: Проф. Д-р Виктор Гаврилоски}

\begin{document}
    \sloppy
    \pagenumbering{gobble}
    \maketitle{}
    \newpage
    \tableofcontents
    \newpage
    \pagenumbering{arabic}
\section{Вовед}
  Индустријата бурно и брзо има претрпено големи промени во минатата декада, и се очекува дека таа брзина на промена сеуште ќе се зголемуваа во наредните години. Два фактори кои се дел од причината за новата индустриска револуција се напредувањата во сензорската и процесорската технологија.\bigbreak
  Подобрувањето во сензорската технологија доведува до две главни придобивки: пософистицирани сензори и драстично поевтини сензори. Овие два факти се очигледни кај главниот сензорски склоп на кој што се потпираа оваа дипломска работа - Kinect-от од Microsoft. Сензорот спојува обична камера во боја (RGB) со интегрирана инфрацрвена матрица, односно длабинска камера (D), создавувајќи еден софистициран композитен сензор (RGB-D Камера) чија технологија поседува голем потенцијал за примена во роботика, оптимизација на производни процеси, безбедносната индустрија, а дури и во автономните возила и медицинската индустрија.
  \bigbreak
  Но, суровата информација од самата камера е прилично обемна. Грубо пресметано, $2,4 \times 10^6$ пиксели стигнуваат до камерата, $2,1 \times 10^6$ од кои што се 4-бајтни вредности (YUYV формат), додека останатите 300.000 се 1-бајтни вредности. Ова изнесува $8,6 \times 10^6$ бајти, или 8,6MB по слика. Со фреквенција на семплирање од 30Hz, целосната пресметка изнесува 258МB/s. Оваа брзина на пренос на информација не би била ни замислива пред 30 години, но денес е секојдневие.
  \\
  Од тука следи усогласувањето на сликите од двете засебни камери (\textit{matching}) и, во наш случај, наоѓањето на 1-6 луѓе и нивното симултано положбено следење преку 26 зглобни врски.
  \\
  Реалноста дека ваква пресметка може да се изведе во реално време со стандарден персонален компјутер и сензор од €150 е факт што е прилично возбудлив.
  \bigbreak
  Главниот дел од оваа дипломска работа ќе биде составен од управувањето на еден робот од National Instruments со диференцијален погон. Целта на управувањето е да се постигне робустно и надежно следење на човек, одржувајќи го растојанието зададено од човекот преку гестикулации на рацете.
  \\
  %Покрај овој главен фокус, дипломската исто пружи примери за примената на самиот Kinect во областа на индустриска автоматизација, како и примери за рачно управување на самиот робот преку bluetooth контролери.

\newpage

\section{Kinect v2 за Windows}
	Kinect-от од Microsoft претставува композитен сензор составен од една обична RGB (\textit{Red-Green-Blue}) камера и една матрица на инфрацрвени предаватели/приемници, која служи како D (\textit{Depth} - Длабинска) камера. Оваа D камера се нарекува и Time of Flight (ToF) камера, односно камера што го пресеметува времето на изминатиот пат за секој од нејзините оддадени фотони. Заедно создават еден уред кој што може да се смета концептуално како една RGB-D камера. Kinect-от ја игра улогата на главен сензор во нашата работа; преку алгоритми создадени од машинско учење и преку фузија на двата сензори може да ја препознае скелетната положба на 6 луѓе истовремено, како и отвореноста/затвореноста на нивните раце.

  %*REFERENCE HERE
	Првата верзија на Kinect-от (v1) била создадена од Microsoft во 2010г. како периферен уред за нивниот систем за видео игри - Xbox 360. Првиот Kinect има способност да следи само 2 скелетни положби, и не може да разликува отворени/затворени раце. Во 2013, Microsoft ја изваде Kinect v2, која ги нуди способностите наведени погоре. Иако беше наменет како уред за играње и забава, Kinect-от брзо стана клучен дел од репетоарот на инженерите кои развиваат системи за машински вид поради неговата поволна цена и готови библиотеки. На крајот на ова поглавје е прикачена споредбена табела на двете верзии на Kinect-от.
  %maybe in an appendix instead of the end of the \section{section name}

  \subsection{Time of Flight камери}
  	Time of Flight (ToF) технологиите се стремуваат да го пресметаат растојанието на секоја набљудена точка од центарот на камерата. Главниот принцип на работа на ToF камерите е набљудувањето на времетраењето на летот на предадените фотони. ToF технологијата се дели понатаму во „директен“ (\textit{pulsed}) ToF и „имплицитен“ (\textit{continuous wave}) ToF. Kinect-от се базира на имплицитен ToF.

	\subsubsection{Директен ToF}
		%REFERENCE THIS WHOLE SECTION
		Методата на директен ToF едноставно се базира на принципите на рефлекција на фотони и мерењето на времето потребно за изминување на целата траекторија.

		За еден многу краток период $ \Delta t $ се напојува изворот на светлина. Рефлектираната енергија за секој пиксел се прима, симултано, во по два приемници $C_1$ и $C_2$ кои се со иста фреквенција на семплирање, но се со фазна разлика од $180 \degree$. Се акумулираат два електрични полнежи $Q_1$ и  $Q_2$, кои се користаат за да се пресмета изминатиот пат на фотонот што припаѓа на i-тиот пиксел, односно:
		$$ d = \frac{1}{2} \ c\  \Delta t \frac{Q_2}{Q_1 + Q_2} $$
		Каде што:
		\begin{itemize}
			\item $d$ е изминатиот пат на фотонот ($m$)
			\item $c$ е брзината на светлина ($ 3 \times 10^8\ ms^{-1} $)
			\item $\Delta t$ е времетраењето на светлосниот импулс ($s$)
			\item $Q_1$ и $Q_2$ се семплираните електрични полнежи.
			\end{itemize}

		\begin{figure}[H]
			\includegraphics[width=0.75\linewidth]{./images/impulseToF.png}
			\centering
			\caption{Приказ на мерниот протокол на директен ToF}
			\label{fig:impulseToF.png}
			\end{figure}

	\subsubsection{Имплицитен ToF}
		Методата на имплицитен ToF (наречен \textit{Continuous Wave ToF} на англиски) се разликува од директниот на еден клучен начин: Имплицитната метода го мери фазното отстапување помеѓу примениот и оддадениот зрак, кој што непрекинато се испраќа, додека директниот метод работи со директно мерење на време и дискретни импулси. Од оваа добиена фазна разлика, потребни се уште неколку пресметки за да се добие време на изминат пат.

		За разлика од начинот на семплирање кај директната метода, имплцитната метода семплира четири пати при секое мерење, со фазно отстапување на $90\degree$. Со оваа техника, фазниот агол помеѓу оддаден и рефлектиран бран $\phi$ и од тоа растојанието $d$ следат:

		$$ \phi = atan(\frac{Q_3 - Q_4}{Q_1 - Q_2}) $$
		$$ d = \frac{c}{4\pi f} \phi $$
		Каде што $c$ е брзината на светлината.


		Од тука, следат и пресметките на интезнитетот на пикселот $A$ и нултото отстапување (\textit{bias}-от) $B$:

		$$ A = \frac{\sqrt{(Q_1 - Q_2)^2  + (Q_3 - Q_4)^2}}{2} $$
		$$ B = \frac{Q_1 + Q_2 + Q_3 + Q_4}{2} $$


		\begin{figure}[H]
			\includegraphics[width=0.75\linewidth]{./images/CWToF.png}
			\centering
			\caption{Приказ на мерниот протокол на имплицитен ToF}
			\label{fig:CWToF.png}
			\end{figure}

		Иако имплицитните равенки се навидум безпотребно сложени, всушност одземачките термини го амортизираат влијанието на нултите отстапувања, додека квоциентот во фазната пресметка ги анулира ефектите од било кои системски или рефлектирани засилувања.\\
		Следната равенка ја опишува варијацијата на пресметана длабинска информација како фунцкија на $A$ и $B$, како и фреквенцијата на оддадената светлина $f$ и модулациониот контраст $c_d$:

		$$ \sigma = \frac{c}{4\sqrt{2\pi f}} \cdot \frac{\sqrt{A+B}}{c_d A} $$

		Од равенката може да извлече заклучокот дека надежливоста на измерените длабини се подобрува со повиска работна фреквенција, висок модулционен контраст, и при јак светлосен интензитет, додека се влошува прецизноста при високо нулто отстапување.
		\\
		Една многу битна појава која што треба да се земе во предвид е појавата на алиасинг. Бидејќи имплицитната метода се базира на фазни разлики кои се повторуваат, ќе се појави растојание на двосмисленост $d_{dvo}$ кое се дефинира според равенката:

		$$ d_{dvo} = \frac{c}{2f} $$

		Сензорот е неупотреблив на растојанија поголеми од $d_{dvo}$, бидејќи не се разликува измерената вредност $z$ од било која вредност $z + k d_{dvo}\ | \ k \in \mathbb{N}$.

\newpage

\section{Алгоритам за препознавање}

  Постојат неколку различни компоненти кои што го прават Kinect-от пробив во технологијата. Хардверот е добро дизајниран и ја извршува својата функција при што има прифатлива цена. Меѓутоа, штом вниманието се тргне од брзото мерење на растојание, тоа се фокусира на методот за следење на тела. Во овој случај тој претставува класична техника за препознавање шеми која што е карактеристично имплементирана.\bigbreak

	Претходните уреди за следење на тела имаат недостаток - за да го следат телото, човекот мора да застане во калибрациона поза за да се овозможи употреба на алгоритам за барање усогласеност во делови од сликата. Од тука се користи логиката дека ако раката на телото се наоѓа во одреден регион во првата слика, тогаш во наредната слика таа рака нема нема да може да се има задвижено далеку од претходниот регион, и само се бара усогласување во близина на тој регион.\bigbreak

	Иако логиката е добра, се јавува проблем доколку се изгуби локацијата на телото за било која причина, доколку објект кој и само за момент го попречи телото кое што се следи. Следењето на поголем број на тела значително ја отежнува работата, и доколку се изгуби следењето на некое тело, тоа тешко може да се врати.\bigbreak

	Тоа што го прави Kinect-от не е следење на веќе препознаено тело, туку лоцирање на делови од телото со локална анализа на секој пиксел од сликата. Традиционалното препознавање на шеми работи преку тренирање на одлучувачка структура (со користење на машинско учење) со голем број на примероци на објектот кој што треба да го препознае. Тренирањето на одлучувачката структура се изведува со доведување на голем број на мерења од т.н. „особини“ на класификатор кои што треба да содржат потребни информации за препознавање на објектот, при што најчесто тешкиот дел е одредувањето на особините кои што треба да се мерат.\bigbreak

	Овие особини се базирани на едноставна формула:

  \begin{equation} \label{eq:depth}
	  f_\theta(I,\textbf{x}) = d_I(\textbf{x}+\frac{\textbf{u}}{d_I(\textbf{x})}) - d_I(\textbf{x}+\frac{\textbf{v}}{d_I(\textbf{x})})
    \end{equation}
  \\
  каде што $d_I(\textbf{x})$ е длабочината, односно растојанието од Kinect-от кај пикселот \textbf{x} во слика $I$, и параметрите $\theta = (\textbf{u},\textbf{v})$ ги опишуваат офсетите (offsets) \textbf{u} и \textbf{v}.

  \begin{figure}[H]
	  \includegraphics[width=0.35\linewidth]{./images/kinectfeature.png}
		\centering
		\caption{Репрезентација на горенаведената формула}
		\label{fig:kinectfeature.png}
	  \end{figure}

	Во формулата, поместувањето (offset) се дели со $d_I(\textbf{x})$ со цел да се направи независно од длабочината, а истовремено да се зголемува или намалува во зависност од големината на објектот. Како излез од $f$ добиваме информации за 3D обликот на просторот околу разлгледуваниот пиксел $x$.\bigbreak

  На сл. \ref{fig:depth_features.png} се прикажани две особини за различни пиксел локации \textbf{x}. Особината $f_{\theta_1}$ гледа нагоре од каде равенката \ref{eq:depth} ќе даде голема позитивна вредност за пиксели \textbf{x} во близина на врвот на телото, но за пиксели \textbf{x} во пониска локација на телото ќе даде вредност блиску до нула. Од друга страна особината $f_{\theta_2}$ може да се користи за одредување на тенки вертикални структури, како на пример рацете.

  \begin{figure}[H]
    \includegraphics[width=0.75\linewidth]{./images/depth_features.png}
    \centering
    \caption{Особини на длабинската слика}
    \label{fig:depth_features.png}
    \end{figure}

  Бидејќи ова не е доволно за да се одреди дали објект е еден екстремитет или друг, се применува машинско учење.

  %	\subsection{Машинско учење}
	Машинско учење претставува наука која се занимава со постигнување на посаканото однесување на компјутери без дирекнто наредбено програмирање. Во минатата деценија, машинското учење имаат овозможено автономни возила, практично препознавање на говор, ефективно пребарување на интернет, и значително подобрено познавање на човечкиот геном. Машинското учење во денешно време е толку продорно што луѓето го користат десетици пати дневно без тоа да го знаат. Многу научници исто сметаат дека тој е најдобриот начин за правење напредок кон вештачка интелигенција која е на ниво на човек.

	Задачите на машинско учење во главно се класифицирани во две пошироки категории, во зависност од тоа дали има влезен „тренинг“ сигнал или повратна врска доведена во системот за учење:

	\begin{itemize}
		\item \textit{Надгледувано учење}\\Компјутерот добива пример влезови и нивни посакани излези, кои што се дадени од „учител“, и целта е да научи генерално правило кое што пресликува влезови на излези.
    \begin{itemize}
      \item \textit{Полу-надгледувано учење}\\Компјутерот добива нецелосен тренинг сигнал: множество на тренинг елементи од кои недостасуваат неколку (често повеќе) посакувани излези.
      \item \textit{Активно учење}\\Компјутерот може да добие именувани информации само од ограничен број на тренинг примери (базирано на буџет), и исто така мора да го оптимизира својот избор на објекти за кои ќе добива именувани информации. При негово користење во интерактивна средина можно е да ги презентира на корисникот за именување.
      \item \textit{Засилено учење}\\Компјутерот добива информации (во форма на награди или казни) само преку повратна врска. Видот на информации зависи од акциите на програмата во динамичка средина, како на пример управување на возило или игра со противник.
      \end{itemize}
		\item \textit{Ненадгледувано учење}\\Компјутерот не добива именувани информации, односно се остава алгоритамот за учење сам по себе да пронајде структура по која ќе ги групира влезовите.
    \end{itemize}

  Алгоритам за машинско учење кој што пресликува податоци во соодветна категорија се нарекува класификатор (Classifier). Еден пример за класификатор е т.н. „дрво на одлучување“. дрво на одлучување претставува алат за поддшка на одлучување кое користи дијаграм или модел во форма на дрво, составено од одлуки и нивни можни последици.\\
  Во Kinect-от се користи „шума на одлучување“ што всушност претставува збир на поголем број дрва. Секое дрво се тренира на неколку особини користејќи длабински слики кои имаат претходно означени делови од телото, се додека не дава точни класификации за одреден дел од телото за повеќе тест слики.

  Овие тренирани класификатори доделуваат вредост за веројатност, односно колку сигурни се дека тој пиксел припаѓа на одреден дел од телото, а наредниот алгоритам ги избира најверојатните области за секој различен дел од телото. Според тоа, одредена површина пиксели ќе биде сместена во категоријата „рака“ ако класификаторот за препознавање на раце има најголема вредност за веројатност во таа област во споредба со другите класификатори за различни делови на телото. Последниот чекор се состои од цртање на претпоставени локации на соодветни врски(joints) во тие области.

  \begin{figure}[H]
    \includegraphics[width=0.75\linewidth]{./images/bodyparts.png}
    \centering
    \caption{Алгоритам за препознавање}
    \label{fig:bodyparts.png}
    \end{figure}

  Бидејќи пресметката користи само длабински информации за три пиксели и може да се обработи од страна на GPU-то, системот може да работи со 200 слики во секунда (fps) и нема потреба од калибрациона поза. Секоја слика се обработува посебно поради што нема следење и нема опасност од губење на локацијата на телото, по што мора да се повтори калибрационата поза, и исто така постои можност за следење на поголем број на тела истовремено.

\newpage

\section{Начин на програмирање на Kinect-от во C++}
  Програмирањето на Kinect-от, односно неговото отчитување, не е сосема едноставно, туку неколку чекори се потребни за да се стигне до добивањето на самата слика.

  \begin{figure}[H]
    \includegraphics[width=0.75\linewidth]{./images/programming_flow_trimmed.png}
    \centering
    \caption{Општ протокол за отчитување на Kinect-от}
    \label{fig:programming_flow_trimmed.png}
    \end{figure}

  Причината за оваа сложеност е поради големата количина на можности пружена од интерфејсот за програмирање од Microsoft. За секој член од отчитувачкиот процес постои барем една опција која би влијаела на крајната слика.

  \subsection{Пример на отчитување}
    %RIP GRAMMAR
    Со следната програма се детектира до 6 луѓе, и врз нивните тела се цртаат скелети. Истовремено се праќа состојбата на нивните раце и се прикажува со обоени кругови, во зависност од тоа дали тие се отворени, затворени, или во „лассо“ состојби (два кренати прсти). Секој од зглобовите има свои координати во декартов систем со центар во средината на самиот Kinect:
      \begin{verbatim}
          #include "stdafx.h"
          #include <iostream>
          #include "util.h"
          #include <thread>
          #include <chrono>
          #include "ppl.h"
          #include "Kinect2_Tools.h"
          int main(int argc, char ** argv){
            try {
                Kinect kinect;
                kinect.initializeSensor();
                kinect.initializeColor();
                kinect.initializeBody();

                while(true){
                  kinect.updateColor();
                  kinect.updateBody();
                  kinect.drawColor();
                  kinect.drawBody();
                  kinect.showBody();
                }

                 }
            catch (std::exception &except)
            {
              std::cout << except.what() <<std::endl;
            }
          }
        \end{verbatim}

    Кодот е скратен со помош на фунцкиите што ги напишавме и вградивме во проектот преку \verb|#include "Kinect2_Tools.h"| командата. Во прилог е прикачен целиот header фајл.

    \begin{figure}[H]
      %\includegraphics{an-image-that-doesnt-exist-yet.png}
      \centering
      \caption{Излез добиен од горе наведената програма}
      \label{fig:an-image-that-doesnt-exist-yet.png}
      \end{figure}

\newpage

\section{DaNI}
  \begin{figure}[H]
    \includegraphics[width=0.6\linewidth, keepaspectratio]{./images/dani_isometric.jpg}
    \centering
    \caption{Роботот DaNI}
    \label{fig:dani_isometric.jpg}
    \end{figure}

	National Instruments (NI) LabVIEW комплетот за роботика се состои од DaNI 2.0 (сл.\ref{fig:dani_isometric.jpg}), кој содржи:

	\begin{itemize}
		\item Pitsco Education 12 VDC мотори со 152 rpm и 21.6 kg-cm вртежен момент
		\item Оптички квадратурни енкодери со 400 импулси при револуција
		\item PING))) ултразвучен сензор за мерење на растојанја помеѓу 2cm и 3m
		\item PING))) монтажен држач за работен агол од $180 \degree$
		\item Два Pitsco Education TETRIX 10.16cm тркала и едно омни тркало за насочување
		\item sbRIO единица и соодветни кабли за поврзување
		\end{itemize}

	Хардверот може да биде проучуван, обратно инжениран, и модифициран од студенти. Меѓутоа, главната цел е роботска перцепција и контрола кои се имплементирани во LabVIEW софтвер развиен на одделен сервер (компјутер) и спуштен на роботскиот компјутер.

	\begin{figure}[H]
		\includegraphics[width=0.75\linewidth]{./images/dani_block_diagram.png}
		\centering
		\caption{Блок дијаграм на DaNI}
		\label{fig:dani_block_diagram.png}
		\end{figure}

	\subsection{Актуатори}
		Од страната на актуатори, DaNI поседува два DC мотори со вградени редуктори, и еден серво мотор. DC моторите се користат за движење на роботот, а серво моторот има улога прецизно да го ротира PING))) ултразвучниот сензор. Подолу се наведени нивните карактеристики.

	  \subsubsection{DC мотори}
		  DC мотор со четкици претставува внатрешно комутиран електричен мотор дизајниран да биде напојуван со извор на еднонасочна струја. Неговата брзина може да се менува со промена на работниот напон или јачината на магнетото поле.
		  Во DaNI се применети два DC мотори, поточно TETRIX MAX DC мотори(сл.\ref{fig:dc_motor_iso.png}).

		  \begin{figure}[H]
    	  \includegraphics[width=0.35\linewidth]{./images/dc_motor_iso.png}
			  \centering
			  \caption{Tetrix Max DC мотор}
			  \label{fig:dc_motor_iso.png}
			  \end{figure}

      \begin{table}[h]
        \caption{Карактеристики на DC моторите}
        \label{tab:dcmotor}
        \begin{center}
          \begin{tabular}{||c|c|c||}
            \hline
            При нормални услови: & & \\
            \hline
             & Номинален Напон & $6-13.8V$\\
             & Температура на Околина & $-10 \pm 60 \degree C$\\
            \hline
            Услови на Испитување: & & \\
            \hline
            & Напон & $12V$ \\
            & Температура на Околина & $28 \degree C$\\
            & Влажност на Воздухот & $44\% Рел.$\\
            \hline
            Електрични Особини: & & \\
            \hline
            Неоптоварен: & & \\
            \hline
            & Брзина & $150 \pm 10 \ vrt/s$ \\
            & Струја & $0.34А\ (0.68A max.)$ \\
            \hline
            Оптоварен: & &\\
            \hline
            & Вртежен Момент & $0.382Nm $\\
            & Струја & $0.91А (1.37А max.)$\\
            & Брзина & $137.5 \pm 10 \%\ vrt/s$\\
            \hline
          \end{tabular}
        \end{center}
      \end{table}


		\begin{comment}  \renewcommand{\theenumii}{\arabic{enumii}}
        \renewcommand{\theenumiii}{\arabic{enumiii}}
	      \begin{enumerate}
        \item При нормални услови на работа:
          \begin{enumerate}
            \item Номинален напон: $ 6-13.8 V $
					  \item Температура на околината: $ -10 \pm 60 \degree C $
					  \item Насока на ротација: Спротивно од стрелката на часовникот\\Позитивен пол поврзан со црвен „+“\\Негативен пол поврзан со „-“\\Гледајќи кон оската на излезното вратило
					  \end{enumerate}
		    \item Услови на испитување:
          \begin{enumerate}
            \item Напон: DC 12 V
            \item Температура на околината: $ 28 \degree C $
            \item Влажност на воздухот: 44 \% RH
            \item Испитуваниот уред е поставен хоризонтално
            \end{enumerate}
	  	  \item Електрични способности(По 30 секунди напојување)
        	\begin{enumerate}
            \item Без оптоварување
              \begin{enumerate}
                \item Брзина: 150 $\pm$ 10 RPM
                \item Струја: 0.34А (0.68А max)
                \end{enumerate}
				    \item Со оптоварување
              \begin{enumerate}
                \item Вртежен момент: 3.9kg.cm
                \item Струја: 0.91А (1.37А max)
                \item Брзина: 137.5 $\pm$ 10 \% RPM
                \item Вртежен момент на запирање: /
                \item Струја на запирање: /
                \end{enumerate}
            \end{enumerate}
	      \item Механички карактеристики
          \begin{enumerate}
            \item Аксијално поместување на вратилото: $\leq$ 0.5mm
            \end{enumerate}
        \item Својства на моторот:
          \begin{enumerate}
            \item Струја без оптоварување: 0.19А
            \item Брзина без оптоварување: 11000 $\pm$ 10 \% RPM


            \end{enumerate}
        \end{enumerate}
      \end{comment}

		  Двата DC мотори присутни во конструкцијата се контролирани со помош на Sabertooth Dual 10A Motor Driver. Тој може да напојува два DC мотори со четкици со струја до 10А поединечно, со максимални 15А за кратки временски периоди, со многу тивка операција поради ултрасоничната брзина (32kHz) на контрола на неговите транзистори. Sabertooth исто така претставува првиот синхрон регенеративен мотор драјвер во својата класа. Регенеративната топологија значи дека батериите на уредот се полнат кога на уредот му се наредува да забави или да се врати назад, при што исто така ја зголемува и брзината на реакција. Вклучува внатрешно напојување од 5V кое може да напојува микроконтролер или R/C приемник.

		  Наредно се зададени техничката скица(сл.\ref{fig:motor_schematic.png}) на моторот со неговите димензии, како и графикот на карактеристики на моторот за различно оптоварување(сл.\ref{fig:motor_graph.png}). Овој график ги дава целокупните карактеристики, т.е. карактеристиките на моторот заедно со редукторот.

      \begin{figure}[H]
        \includegraphics[width=0.75\linewidth]{./images/motor_schematic.png}
		    \centering
        \caption{Техничка скица на DC моторот}
		    \label{fig:motor_schematic.png}
		    \end{figure}

	    \begin{figure}[H]
		    \includegraphics[width=0.75\linewidth]{./images/motor_graph.png}
		    \centering
		    \caption{Карактеристични вредности на DC моторот}
		    \label{fig:motor_graph.png}
	      \end{figure}

    \subsubsection{Серво мотор}
      Серво мотор е ротационен актуатор кој дозволува за прецизна контрола на аголна позиција. Тој се состои од мотор поврзан со сензор за повратни информации за позиција. Исто така има потреба од серво драјвер, кој прима команден сигнал од контролен систем, го засилува сигналот, и пренесува електрична струја до серво моторот со цел да произведе движење пропорционално со командниот сигнал. За оваа цел го користи и сензорот за повратни информации за позиција за да се добие прецизна контрола на ротационата позиција на моторот. Ова е т.н. систем со затворена повратна врска.

      Единствена функција на серво моторот во оваа конструкција е ротација на PING))) сензорот, поради што тој не е изложен на значителни оптоварувања.

      \begin{table}[h]
        \caption{Карактеристики на серво моторот}
        \label{tab:servomotor}
        \begin{center}
          \begin{tabular}{||c|c||}
            \hline
            Димензии & 39.88 х 19.81 х 37.85mm\\
            \hline
            Тежина & 45g\\
            \hline
            Ранг на напон & 4.8V - 6.0V\\
            \hline
            Брзина без оптоварување (4.8V) & 0.22sec/60\degree\\
            \hline
            Брзина без оптоварување (6.0V) & 0.18sec/60\degree\\
            \hline
            Вртежен момент на запирање (4.8V) & 4.8kg.cm\\
            \hline
            Вртежен момент на запирање (6.0V) & 6.0kg.cm\\
            \hline
            Максимален ранг на PWM & 553-2425\micro sec\\
            \hline
            Поминат агол по \micro sec & .102\degree/\micro sec\\
            \hline
            Максимален пат & 190.5\degree \\
            \hline
            Амплитуда на импулс & 3-5V \\
            \hline
            Работна температура & -20\degree C до +60\degree C \\
            \hline
            Потрошувачка на струја - неактивен (4.8V) & 8mA \\
            \hline
            Потрошувачка на струја - неактивен (6V) & 8.8mA \\
            \hline
            Потрошувачка на струја - без оптоварување (4.8V) & 150mA \\
            \hline
            Потрошувачка на струја - без оптоварување (6V) & 180mA \\
            \hline
            Можност за континуирана ротација & + \\
            \hline
            Насока со зголемување на PWM сигнал & Во насока на часовата стрелка \\
            \hline
            Вид на запченици & Запченици со прави заби \\
					  \hline
            Материјал на запченици & Карбонит \\
            \hline
            \end{tabular}
          \end{center}
        \end{table}

		  \begin{figure}[H]
        \includegraphics[width=0.75\linewidth]{./images/servo_schematic.png}
        \centering
        \caption{Димензии на серво моторот}
        \label{fig:servo_schematic.png}
        \end{figure}

    \subsubsection{PWM}
    	PWM (Pulse Width Modulation) е начин на аналогно управување базиран на употребата на чисто дигитални сигнали. При една претходно одредена фреквенција, имаме една соодветна периода, $T(s)$. Во рамките на една периода, можеме да ја дефинираме врската помеѓу времетраењето на активноста (ОN) и времетраењето на неактивноста (OFF) на еден дигитален излез. Добиениот „аналоген“ излез (ефективниот напон) се пресметува со следната равенка:\\

      $$ V_{PWM} = V_{dig} \cdot \frac{T_{ON}}{T_{ON} + T_{OFF}} = V_{dig} \cdot \frac{T_{ON}}{T} $$

      На пример, ако имаме работна фреквенција 20kHz, имаме периода $50\mu s$. Нека дигиталниот излез биде 5V (т.е. ON = 5V, OFF = 0V). Ако за $30\mu s$ од секоја периода задаваме ON сигнал, а за останатите $20\mu s$ задаваме OFF сигнал, на излез ќе го добиеме ефективен напон:

      $$ V_{PWM} = 5 \cdot \frac{30}{30+20} = 5 \cdot 0.6 = 3V $$

  \subsection{Сензори}
    Во најширока дефиниција, сензор претставува уред, модул или подсистем чија задача е да препознае настани или промени во својата околина, и да испрати согласна информација кон останатата електроника (најчесто компјутерски процесор).

    Во DaNI употребуваме два вида на сензори: енкодер и ултразвучен сензор.

    \subsubsection{Енкодер}
      Ротационен енкодер, е електромеханички уред кој ја претвора аголната позиција или движење на вратило во аналоген или дигитален сигнал.

		  Постојат два главни видови: апсолутни и инкрементални (релативни). Излезот од апсолутни енкодери ја изразува моменталната позиција на вратилото, што ги прави аголни трансдусери. Излезот на инкрементални енкодери дава информација за \textit{движењето} на вратилото кое понатаму се процесира во информации како за брзина, растојание и позиција.

		  Ротационите енкодери се користат во многу области на апликации кои имаат потреба од прецизна контрола на неограничена ротација на вратило, вклучувајќи индустриски контрола, роботика, фотографски леѓи за специјални примени, компјутерски влезни уреди, и ротациони радарни платформи.

		  Во нашиот случај, енкодерот е инкрементален квадратурен енкодер(сл.\ref{fig:encoder.png}), што значи дека користи два излеза A и B кои се наоѓаат на 90 \degree фазно поместување еден од друг(сл.\ref{fig:encoder_quadrature.png}).

		  \begin{table}[h]
        \caption{Зголемување на фазата имплицира ротација во насока на стрелките на часовникот}
        \label{tab:fazno}
        \begin{center}
          \begin{tabular}{||c|c|c||}
            \hline
            Фаза & A & B \\
            \hline \hline
            1 & 0 & 0 \\
            \hline
					  2 & 0 & 1 \\
            \hline
            3 & 1 & 1 \\
            \hline
            4 & 1 & 0 \\
            \hline
            \end{tabular}
          \end{center}
        \end{table}

      \begin{figure}[H]
        \includegraphics[width=0.5\linewidth]{./images/encoder_quadrature.png}
        \centering
        \caption{Два квадратни бранови во квадратура (ротација во насока на стрелките на часовникот)}
        \label{fig:encoder_quadrature.png}
        \end{figure}

      Исто така дискот има 400 отвори, односно енкодерот има резолуција од 0.9\degree.

      \begin{figure}[H]
        \includegraphics[width=0.5\linewidth]{./images/encoder.png}
        \centering
        \caption{Шема на оптички енкодер}
        \label{fig:encoder.png}
        \end{figure}

    \subsubsection{Ултразвучен сензор}
      Ултразвучниот сензор PING))) од Паралакс(сл.\ref{fig:ping_dims.png}) е способен да извршува прецизни мерења на растојанија од 2cm до 3m. Лесно се приклучува на микроконтролери како BASIC Stamp, Propeller chip, или Arduino, користејќи само еден I/O пин. Се напојува со 5V и 30mA.

		  PING))) сензорот работи со пренесување на ултрасончен (високо над осетливиот ранг на човекот) збир (burst) на бранови, и произведува излезен пулс кој соодветствува на времето потребно за ехото на брановите да се врати до сензорот. Со мерење на ширината на излезниот пулс, лесно може да се пресмета растојанието до објектот.

		  \begin{figure}[H]
        \includegraphics[width=0.75\linewidth]{./images/ping_dims.png}
        \centering
        \caption{Димензии на PING))) сензорот}
        \label{fig:ping_dims.png}
        \end{figure}

      \begin{figure}[H]
        \includegraphics[width=0.75\linewidth]{./images/ping.png}
        \centering
        \caption{Шема и принцип на дејство на ултразвучен сензор}
        \label{fig:ping.png}
        \end{figure}

		  \paragraph{Протокол на комуникација\\}
        PING))) сензорот детектира предмети со емитирање на краток ултрасоничен збир (burst) на бранови, и потоа со „слушање“ за ехото. Под контрола на главен микроконтролер (пулс на активација), сензорот емитира краток 40kHz сигнал. Овој сигнал патува низ воздухот, се судира со објект и се одбива назад кон сензорот. Истовремено сензорот испраќа излезен пулс на микроконтролерот кој ќе се прекине штом се детектира ехото, кој всушност ни го дава растојанието до предметот(сл.\ref{fig:ping.png}).

      \begin{figure}[H]
        \includegraphics[width=0.75\linewidth]{./images/ping_sig.png}
        \centering
        \caption{Изглед на сигналот}
        \label{fig:ping_sig.png}
        \end{figure}

      \begin{table}[H]
        \caption{Карактеристики на сигналот}
        \label{tab:signalchar}
        \begin{center}
          \resizebox{\textwidth}{!}{%
          \begin{tabular}{||c|l|l|l|l||}
            \hline
            Темна линија & Главен Уред & Влезен пулс на активација & $ t_{OUT} $ & $2\mu s$ (min), $5\mu s типично$ \\ \hline
            \multirow{5}{*}{Светла линија} & PING))) Сензор & Задржување на ехо & $ t_{HOLDOFF} $ & $750\mu s$ \\
            & & Фреквенција на сигналот (burst) & $ t_{BURST} $ & $ 200\mu s $ @ $ 40kHz $ \\
            & & Ехо повратен сигнал минимум & $ t_{IN-MIN} $ & $ 115\mu s $ \\
            & & Ехо повратен сигнал максимум & $ t_{IN-MAX} $ & $ 18.5\mu s $ \\
 						& & Пауза пред следно мерење & & $ 200\mu s $ \\
						\hline
            \end{tabular}}
          \end{center}
				\end{table}

      \paragraph{Позиционирање на објектот\\}
        PING))) сензорот не може прецизно да измери растојание до објект кој што:

      \renewcommand{\theenumi}{\alph{enumi}}
      \begin{enumerate}
        \item се наоѓа подалеку од 3m
        \item има мал агол на рефлектирачката површина со што сигналот нема да биде одбиен назад кон сензорот
        \item е премногу малечок за да рефлектира доволно звук назад кон сензорот
        \end{enumerate}

		  Дополнително, доколку PING))) сензорот е поставен на ниска позиција на уредот, има можност да детектира звук кој се одбива од подот.

      \begin{figure}[H]
        \includegraphics[width=0.75\linewidth]{./images/ping_obj.png}
        \centering
        \caption{Позиционирање на објектот}
        \label{fig:ping_obj.png}
        \end{figure}

\newpage

\section{NI sbRIO 9632}
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.75\linewidth]{./images/sb_rio_1.png}
		\caption{sbRIO со обележани компоненти}
		\label{fig:sb_rio_1.png}
		\end{figure}

  sbRIO (single-board Reconfigurable Input/Output) управувачките единици од National Instruments претставуваат компјутер монитран на една плочка (single board) наменета за случаи каде што е потребно решение со управување во реално време (Real Time). Оперативен систем кој работи во реално време (RTOS: Real Time Operating System) е изработен со особената цел да извршува функции кои барат големо ниво на временска прецизност и висок степен на надежност. За некој систем да се смета за RTOS, тој мора да има познато максимално време на извршување за секоја од неговите клучни операции. Системите кои можат сигурно да обезбедат максимален временски одѕив се вели дека работаат во потполно реално време, додека системите кои можат само понекогаш да обезбедат максимален временски одѕив се вели дека работаат во делумно реално време.

	Потребната брзина се постигнува со истовремето користење на FPGA чип и една обична линеарна процесорска единица.

	sbRIO поседува 110 дигитални влезови/излези, 100 од кои се оспособени за PWM (Pulse Width Modulation), а 10 од кои се наменети за ниско-фреквентна намена. sbRIO поседува и 32 аналогни влезови, и 4 аналогни излези со ранг на излез од $ \pm 10\ V$ со $0.1\%$ грешка при типична употреба на $25\degree C \pm5\degree C$.

	sbRIO содржи и 3 сериски „С“ портови за поврзувањето на надворешни модули од NI за проширување на можностите на sbRIO да опфатат и актуација и аквизиција на податоци.

	\subsection{FPGA}
		FPGA, или „Field Programmable Gate Array“, претставува репрограмибилно интегрално коло кој поседува голем број на програмибилни логични порти. Кај обичните микроконтролери, логиката за управување се пишува и компајлира од некои програмски јазик како C, BASIC или некој графички јазик како G (LabVIEW). Во текот на овој процес се сублимираат во процесорски наредби како ADD и MOV. Низата на можните наредби е единствена за секој микропроцесор. Кај FPGA колата, програмата не се сублимира на наредби, туку самата внатрешна архитектура на колото се подредува со електромагнетни полиња. Како резултат, се добива конфигурација на логични порти која ќе ја извршува задачата опишана во првобитната програма. Бидејќи FPGA нудат хардверско решение, нивното работење е често многу пати побрзо од работењето на обичните микроконтролери, но се подраги.

		\begin{figure}[h]
			\includegraphics[width=0.75\linewidth]{./images/fpga_diagram.jpg}
			\centering
			\caption{Приказ на често сретнати термини кај FPGA кола}
			\label{fig:fpga_diagram_jpg}
			\end{figure}

		FPGA колото што се наоѓа во sbRIO-то е моделот Xilinx Spartan 6, кој поседува 6 милиони репрограмибилни логични порти.

\newpage

\section{Теоретска Позадина}
  Here we need:
  \begin{enumerate}
    \item Block Diagram of the Process DONEZO
    \item Formal description of the sensor setup. i.e. Camera takes images, matches, detects bodies. DONEZO?
    \item Describe our processing and selection based on various methods teleop/following
    \item Section on mobile robotics, holonomicity, and differential drives
    \item Section on the vector model and PD control DONEZO?
    \end{enumerate}

  \subsection{Генерален Опис на Системот}
  \label{sec:general_desc}
    Започнувајќи од основната задача на системот, тој има цел да ги препознае личностите пред себе и според некои критериуми наложени од корисникот да одреди која личност најдобро соодветствува на тие критериуми. По тоа, роботот ќе ја следи избраната личност, одржувајќи некое одредено растојание. Брзината на моторите треба да биде доволно голема да се следи човекот со задоволителна брзина, а доволно мала за да не се појавуваат отскокнувања, нагли запирања, или осцилаторни движења.

    Системот се состои од длабинско-бојната камера Kinect од Microsoft и еден Robotics Starter Kit од NI управуван со sbRIO едно-плочен компјутер - исто од NI. Како главна процесорска единица се користи лаптоп кој го води целиот процес во NI LabVIEW.

    Подолу се општо опишани етапите на функционирање:
    \renewcommand{\theenumii}{\arabic{enumii}}
    \renewcommand{\theenumiii}{\arabic{enumiii}}
    \begin{enumerate}
      \item Кинектот слика и праќа информации за бојната и длабинската информација на сцената пред себе со фреквенција од 30Hz кон главната процесорска единица.
      \item Со употреба на алгоритмите за човеково препознавање на Microsoft, се препознаваат луѓето кои се наоѓаат во сцената.
      \item Според критериумот за избор, една од препознатите личности ќе биде избрана за следење, и нејзините декартови координати во однос на камерата се даваат на излез.
      \item Координатите се претворуваат во поларни координати и потоа уште еднаш се претворуваат во облик на општ информациски пакет и се испраќаат до едно-плочниот компјутер на роботот.
      \\
      Важно е да се опомени дека во меѓувреме разновидни процеси работаат паралелно, како што се читачи за промени во засилувањата на системот, посаканото растојание на роботот, и пораки за итно запирање на роботот. Сите овие други видови на информација се претворуваат исто така во општ информациски пакет.
      \item Роботот ги прима и толкува пораките, одлучувајќи кој вид на информација го содржи тој пакет и која вредност ја носи. Во тек на обична употреба, роботот ќе ги прими поларните координати и ќе ги доведе во свој два паралелни ПД управувачи. Подетално ќе е разгледан двојниот-ПД систем во наредно поглавје.
      \item Излезите од ПД управувачите се претворуваат во дигитални PWM излези и се доведуваат до моторските управувачи.
    \end{enumerate}
  \subsection{Блок Дијаграм на Системот}
    Горенаведените елементи сочинуваат еден значително сложен систем, со развиени софтверски компоненти за управување на електромеханичкиот склоп што го претставува роботот. Иако системот е прилично сложен и со безбројно многу меѓузависности помеѓу информационите, електричните, и механичките потсистеми, за наша употреба самиот робот може да се упрости и да се апроксимира како механички систем од втор ред кој е линеарен и временски независен.
    \\
    \begin{figure}[h]
      \centering
    \begin{tikzpicture}
      \draw [->] (0,0) -- (1,0) node[above=0cm, pos=.2]{\small Реф.};
      %summer block
      \draw [thick] (1.25, 0)  circle (0.25cm) node{$\Sigma$} node[below left]{$-$} node[above left]{$+$};
      \draw [->] (1.25, -3) -- (1.25, -0.25);
      \draw [->] (1.5, 0) -- (2, 0) node[above = 0.02cm, pos=.5]{$\vec{x}$};
      \draw [thick](2, -0.75) rectangle (4.2, 0.75) node[above = 0.005cm,pos=.5]{LabVIEW} node[below = 0.05cm, pos=.5]{Управувач};
      \draw [->] (4.2, 0) -- (5, 0) node[above = 0.02cm, pos=.5]{V};
      \draw [thick] (5, -0.75) rectangle (7.2, 0.75) node[above = -0.1cm, pos=.5]{Моторски} node[below = 0.05cm, pos=.5]{Склоп};
      \draw [->] (7.2, 0) -- (8, 0) node[above = 0.05cm, pos=.5]{$\vec{\omega}$};
      \draw [thick] (8, -0.75) rectangle (9.5, 0.75) node[pos=.5]{$\dot x = \frac{\omega}{r}$};
      \draw [->] (9.5, 0) -- (10.5, 0) node[above = 0.05cm, pos=.5]{$\dot x$};
      \draw [thick] (10.5, -0.75) rectangle (11.5, 0.75) node[pos=.5]{\Large $\frac{1}{s}$};
      \draw [->] (11.5, 0) -- (13.5,0) node[above = -0.05cm, pos=.7]{$x\ (m)$};
      \draw [fill] (12,0) circle (0.05cm);
      \draw (12, 0) -- (12, -3);
      \draw [->] (12, -3) -- (8, -3);
      \draw [thick] (8, -3.75) rectangle (6, -2.25) node[pos=.5]{Кинект};
      \draw (6, -3) -- (1.25, -3);
    \end{tikzpicture}
    \caption{Блок дијаграм на усвоениот систем}
    \label{fig:blok_sema_real}
    \end{figure}
    \\
    Каде што:
    \begin{itemize}
      \item Реф. е референтното растојание на роботот кое што е побарано од корисникот.
      \item Векторот $\vec{x}$ ги претставува пропорционалните и диферецијалните компоненти на промената на растојанието.
      \item Блокот \textbf{LabVIEW Управувач} го претставува алгоритамот изведен во LabVIEW.
      \item $V$ е излезниот напон кој што се доведува до моторите.
      \item Излезот од моторите е $\omega = \theta/s$ во радијани.
      \item Излезот на претворувачкиот блок е брзината на роботот во $m/s$.
      \item По интегрирање со интеграторот $\frac{1}{s}$ се добива изминатиот пат на роботот во метри.
    \end{itemize}

  \subsection{Мобилна Роботика}
    Стационарните индустриски роботи во вид на роботски раце се употребуваат во големосериското производство на автомобили дури од 1980тите, каде што драстично ја подобрија продуктивноста во средини каде што работата е повторлива, бара голема прецизност, и/или е опасна.
    \bigbreak
    %Basically completely translated. I'd prefer to rework this
    Мобилните роботи би нашле - и наоѓаат ден денеска - примена во разновидни средини поради слични причини. Интелигентни и мобилни роботи можат да најдат примена во земјоделство, производство, болници, обезбедување, мерења во средини кои се штетни за човекот, како и безбројни воени употреби.
    \\ %we should ask viktor about words like that. He'll just choose one.
    Постојат разновидни елементи кои се применуваат за задвижување на роботите, како што се: нозе, тркала, и траки. Благодарение на модерните производни технологии и материјали, изводливи се начини на задвижување кои се моделирани на појави во природата (\textit{biomimicry}), како што се: перки, крилја, и нозе.

    \subsection{Холономност и диференцијален погон}
      Изборот на начинот на задвижување не се врши само согласно со условите на средината во која ќе функционира роботот, туку и со пресметковните ограничувања и потребите за агилно движење и степените на слобода. Тука се воведува концептот на \textbf{холономност}. За робот се вели дека е холономен кога тој поседува можност за директно управување во секој од своите степени на слобода. Односно, рамнински робот (како нашиот) со три степени на слобода ($\theta,\ x,\ y$) е холономен ако тој има директна можност за задвижување по оска $x$, $y$, и да се ротира околу $\theta$. DaNI роботот, како и повеќето на роботи во класата на \textit{rovers} ја немаат оваа можност, бидејќи не можат директно да се преместуваат по оската $x$. Овие се нарекуваат \textbf{нехолономни}. За вакво хоризонтално движење, тие мораат да се ротираат, па по своја $y$-оска да се преместуваат додека не ја стигнат посаканата точка, и повторно да се заротираат кон точната ориентација.

      Бидејќи DaNI роботот има два мотори кои независно еден од друг се управуваат, имаме случај на диференцијален погон, каде што линеарната брзина ($\dot y$) е функција на големината на аголните брзини на моторите, додека аголната брзина ($\dot \theta$) е фунцкија на разликата на брзина помеѓу двата мотори. Во случај брзините на десното и левото тркало да се исти по големина а спротивни по знак, роботот би се ротирал вo место, додека еднакви брзини предизвикуваат задвижување нанапред. Секоја друга варијација на брзини предизвукува криволиниско движење по лак со радиус $R$ со центар наречен „моментален центар на ротација“ (МЦР). Равенките за пресметка на $R$, МЦР, и аголната брзина околу МЦР $\omega$ се:
      $$ R = \frac{d}{2} \frac{v_d + v_l}{v_d - v_l} $$
      $$ {MCR} = [x - Rsin(\theta), y + Rcos(\theta)] $$
      $$ \omega = \frac{v_d - v_l}{d} $$
      Каде што:
      \begin{itemize}
        \item $d$ е меѓуосно растојание на тркалата
        \item $v_d$ е аголната брзина на десното тркало
        \item $v_l$ е аголната брзина на левото тркало
        \item $\theta$ е аголот создаден помеѓу осовините на тркалта и X-оската
      \end{itemize}

    \subsubsection{Вектор модел и ПД управување}
      %recognize
      %find spots
      %return coords in m
      %calculate vectors (arg and mod)
      %compare vectors to setpoints
      %parallel PD controllers try to converge error on 0

      Откако камерата го препознае телото, ги наоѓа карактеристичните точки, и ги преобрази нивните податоци од длабинската камера во $ x,y,z $ декардни координати во $ m $ каде што $ 0,0,0 $ е центарот на инфрацрвената камера, $x$ е хоризонталното растојание (лево и десно), $y$ е вертикалното растојание (горе и долу), а $z$ е нормалното растојание од камерата (напред и назад). Преку овие податоци, пресметуваме два вектори, т.е поларните координати - \textbf{аргумент} и \textbf{модулус}, каде што аргумент (\textit{arg}) е аголот, а модулус (\textit{mod}) е растојанието до карактеристичната точка на следеното лице, како што е прикажано на сликата и пресметката подолу.

      %INSERT IMAGE HERE CONTAINING A TOPDOWN VIEW OF THE CAMERA AND A PERSON, MAYBE ALSO A 2ND IMAGE WITH A FRONT VIEW.
      %      \begin{figure}[H]
      %        \includegraphics[width=0.45\linewidth]{./images/kinectView.png}
      %        \centering
      %        \caption{Поглед и координатен систем на камерата}
      %        \label{fig:kinectView.png}
      %        \end{figure}

      \begin{equation} \label{eq:cart2pol}
        \begin{aligned}
    	  mod = \sqrt{x^{2} + z^{2}} \\
        tan(arg) = \frac{x}{z} \\
        arg = tan^{-1}(\frac{x}{z})
        \end{aligned}
        \end{equation}

      Бидејќи најчесто сакаме личноста која што ја следиме да биде во центарот на видното поле на камерата, аргументот треба да се стреми кон вредност 0, додека модулусот треба да се стреми кон вредноста зададена од личноста која што се следи. Управувањето на овие два параметри го постигнуваме со два паралелни ПД управувачи. Едниот ПД управувач е одговорен за оддржување на аргумент 0, и на свој излез дава две инверзни брзини потребни за посаканата ротација, додека другиот ПД управувач е одговорен за модулусот и на излез дава две истонасочни брзини потребни за посаканот праволиниско движење.


      Поради апроксимацијата дека системот е линеарен и временски независен, двата излези од ПД управувачите можат едноставно да се соберат и да се доведе соодветниот напонски сигнал до моторите. Комбинацијата на чиста ротација и чисто праволиниско движење го произведува потребното криволиниско движење. Подолу се опишува целиот процес математички:

      $$      v_d^{rot} = K_p^{rot}(a_{ref} - a_i) + K_d^{rot}(a_i - a_{i-1}) $$
      $$      v_l^{rot} = -v_d^{rot}  $$
      $$      v_d^{lin} = v_l^{lin} = K_p^{lin}(m_{ref} - m_i) + K_d^{lin}(m_i - m_{i-1}) $$
      Според принцип на суперпозиција:
      $$      v_d = v_d^{rot} + v_d^{lin} $$
      $$      v_l = v_l^{rot} + v_l^{lin} $$

  \subsection{Теорија на Боја за Компјутерски Системи}
  \label{sec:colour_theory}
    Во секојдневието, човекот ретко размислува за поимот боја. Објектите си имаат своја боја, и тоа е често крајот на приказната. Кога ќе се разгледа основната физика за бојата, поимот боја се разбира од гледна точка на електромагнетни бранови со посебни фреквенции. Оваа дефиниција е сосема задоволна и исправна за инженерско размислување, но кога се дискутира за поимот на процесирање на слики станува многу важна уште една перспектива на бојата: една боја како три-димензионален вектор во еден конечен простор.
    \\
    Трихроматичната теорија на вид се појавила на почетокот на 18тиот век, кога Томас Јанг преложил дека човековата способност да гледа бои била поради присуството на три различни видови на фотоприемнички клетки во очите. Теоријата била понатаму разработена од Џејмс Максвел и Херман вон Хелмхолц пред да биде физиолошки докажана од Гуннар Сваетчин во 1956та година.
    \bigbreak
    Секои од овие клетки има способност да прима светлина со ниска (црвена), средна (зелена), или висока (сина) фреквентна содржина. Со суперпонирањето на информациите што ќе ги добијаат секои од овие клетки се добива целосната боина информација. Според овој модел, секоја боја може да се разреди во три елементарни компоненти: нејзината црвена (R), зелена (G), и сина (B) компонента. Овие компоненти можат да се ставаат во еден вектор $ V = [R\ G\ B]$.   Човековото око може да препознае од прилика 10 милиони бои, што значи дека просторот во кој овој вектор би постоел е конечен. Ако се смета дека секоја од оските иста тежина носи, тие би имале иста максимална вредност. Ако се направи обид секоја компонента да е опишана со еден бајт, произлегува максимална вредност во било која насока да е 255 и со максималната вредност 255, испаѓа дека целата боја се опишува со еден 24 битен број. Еден 24 битен број може да создаде $2^{24}$ = 16,777,216 комбинации. Од тука произлегува дека конечниот простор е коцка со димензии $a = R_{max} = G_{max} = B_{max} = 255 $, со максимален модулус на вектор $\sqrt{R_{max}^2 + G_{max}^2 + B_{max}^2}$, и со аргументски ограничувања по $\phi$ и $\gamma$ - $0 \leq \phi \leq \pi /2$, и $0 \leq \gamma \leq \pi /2$.

    \begin{figure}[h]
    \label{fig:colour_cube_mk.png}
    \centering
    \includegraphics[width = 0.6\linewidth]{./images/colour_cube_mk.png}
    \caption{Конечниот боен простор}
    \end{figure}

\newpage

\section{Софтверско управување со LabVIEW}
  LabVIEW (Laboratory Virtual Instrument Engineering Workbench) е софтверски пакет наменет за програмирањето на виртуелни уреди (инструменти) за мониторинг и управување на физички уреди. Инструментите што се програмираат во LabVIEW можат да се компајлираат и да се издаваат како комплетно независни програми кои можат да се монтираат како главен управувен софтвер на мехатроничките уреди и машини. LabVIEW инструментите се програмираат користејќи го нивниот сопствен графички програмски јазик, „G“.
  \\
  Основниот пакет на LabVIEW поседува многу од стандардните можности што се очекуваат од било кој програмерски јазик, како што се логички/булови операции, математички операции, и пристап до алатки за визуелизација на податоци.

  LabVIEW поддржува (и понекогаш бара) проширување со додатни пакети. На пример, овие пакети можат да содржат готови под-инструменти (sub-VIs) за обработка на сигнали (Signal Processing), или да овозможуваат соработка помеѓу LabVIEW и некои други технологии (FPGA module). Од овие пакети ние ги употребуваме Real Time, FPGA, и Robotics пакетите. Првите два пакети ни го оспособуваат LabVIEW да програмира FPGA чипови и да управува во реално време, додека Robotics пакетот содржи во себе голем број на готови инструменти за класична и инверзна кинематика, отчитување од сензори, и праќање наредби на моторите.
  \\
  Robotics пакетот исто поседува едно подмножество на инструменти наменети само за DaNI 2.0, и со тие го управувавме DaNI роботот. Исто така, за посебна хардверска поддршка за Kinect и \textit{bluetooth} контролер од PlayStation се употребени библиотеките од \textit{LabVIEW MakerHub}.
  \\
  Да се спомени дека во контекстот на LabVIEW, термините \textit{функција} и \textit{блок} се земени за еднакви по значење, односно за меѓусебно заменливи.

  \subsection{Robotics модул: Starter Kit 2.0}
    Во Robotics модулот на LabVIEW, од интерес ни се готовите VIs за Starter Kit 2.0, кои содржат во нив потпрограми за иницијализација и деиницијализација на роботот и задавање на брзина на ротација на моторите. Тука ќе се набројат и објаснат овие блокови.

		\paragraph{Иницијализација:\\}

			\begin{figure}[h]
				\includegraphics[width=0.45\linewidth]{./images/init.png}
				\raggedright
				\caption{VI за иницијализација}
				\label{fig:init.png}
				\end{figure}

		  Првиот блок служи за иницијализација на роботот. Како влез се доведува IP адресата на DaNI роботот, и според зададената адреса започнува комуникацијата со DaNI. При иницијализација на DaNI се создава „објект“ кој го претставува роботот. Програмерскиот термин „објект“ дефинира конгломерат на податоци и функции коj го опишува некој апстрактен предмет. Овие предмети се често неопипливи, но во случаи како нашиот, овој „објект“ е еден кибернетски претставнички меѓуслој кој ни овозможува комуникација со физичкиот систем во прашање. Како излез на оваа функција го добиваме објектот на DaNI, што ни претставува предуслов за употребата на било која од другите фунцкии. Error-in и error-out портите на VI-то се за заштита при некоја грешка во системот. Ако грешката е 1 (има грешка), целата функцијата на иницијализација се заменува со куса врска, и нема излезен објект. \\

    \paragraph{Деиницијализација:\\}
			\begin{figure}[h]
				\includegraphics[width = 0.45\linewidth]{./images/deinit.png}
				\raggedright
				\caption{VI за деиницијализација}
				\label{fig:deinit.png}
				\end{figure}

      Овој блок се става на крај на програма за да се избрише објектот создаден од иницијализацијата, и да се направи соодветен излез. Без оваа крајна фунцкија, грешки се појавуваат при рестартирање на роботот и промени на програмата.
			\\

    \paragraph{Управување на моторите:\\}
      \begin{figure}[h]
				\includegraphics[width=0.45\linewidth]{./images/write_dc.png}
				\raggedright
				\caption{VI за дефинирање на брзина}
				\label{fig:write_dc.png}
				\end{figure}

			Овој блок е должен за управувањето на брзината на двата DC мотори на DaNI. За функционирањето на блокот потребен е самиот објект на DaNI, како и две вредности за врзините на моторите во \textit{rad/s}. За движење во било која насока, важно е да се опомени дека брзините на моторите морат да бидат со обратен предзнак порадни ниваната обратна поставеност. Моторите имаат максимална брзина на 15.7 \textit{rad/s}.

    \begin{comment}
		  \paragraph{Отчитување од енкодерите:\\}
			\begin{figure}[h]
				\includegraphics[width=0.45\linewidth]{./images/read_dc.png}
				\raggedright
				\caption{VI за отчитување од енкодерите}
				\label{fig:read_dc.png}
				\end{figure}

			Со овој блок се отчитуваат моменталните вредности од енкодерите на двата мотори на DaNI. Излезните вредности се во \textit{rad/s} и имаат \textit{float} формат, и заради тоа можат директно да се прикажат на \textit{display}, во \textit{chart} да се претставаат, или да се вклучат во други пресметки или контролери.

      \paragraph{Отчитување од ултразвучниот сензор:\\}
      \begin{figure}[H]
				\includegraphics[width=0.45\linewidth]{./images/read_ping.png}
				\raggedright
				\caption{VI за отчитување од ултразвучниот сензор}
				\label{fig:read_ping.png}
				\end{figure}

			Овој блок служи за отчитување на информацијата дадена од ултразвучниот сензор, монтиран врз серво мотор на предниот дел од DaNI. Отчитаните вредности се исто во формат \textit{float} и се во мерна единица метри.

      \paragraph{Насочување на ултразвучниот сензор:\\}
			\begin{figure}[H]
				\includegraphics[width=0.45\linewidth]{./images/write_servo.png}
				\caption{VI за насочување на ултразвучниот сензор}
				\label{fig:write_servo.png}
				\raggedright
				\end{figure}
			Со овој блок се управува серво моторот на DaNI, односно се одредува поставеноста на ултразвучниот сензор. Блокот како влезови ги прима објектот на DaNI и посаканиот агол во радијани. Право пред роботот се смета за 0, позитивни вредности го вртат сензорот на лево, додека негативни вредности го вртат сензорот на десно. Доменот на сензорот е $ \pm \frac{\pi}{2}$, или $\pm 90 \degree$.

      \end{comment}

    Внимателниот читач можеби заприметил дека функцијата за отчитување од енкодерите недостига од горенаведеното. Ова е поради две причини. Првата причина е вградениот ПИД управувач во блокот за управување на моторите. Втората причина е тоа што самата повратна логика на управувањето - која ќе биде образложена понатаму - служи за корекција на било кои грешки или нелинеарности во самото физичко управување.

  \subsection{LabVIEW MakerHub модули}
    \subsubsection{Kinect модул}
      Модулот од NI MakerHub за отчитување од Kinect-от во LabVIEW ги сублимира во LabVIEW блокови сите функции за аквизиција на податоци кои што обично би се програмирале во јазик како C++ или C\#. Во оваа дипломска работа, од значење се следните фунцкии:

      \paragraph{Иницијализација:\\}
        Слично како и кај блокот за иницијализација за роботот, оваа фунцкија на излез дава референции кон објектот што ја претставува самата камера, и сигнал на грешка. Во случајот на Kinect-от, нема потреба за доведување на било какви идентификациони информации ако се употребува само една камера.

      \paragraph{Деиницијализација:\\}
        Потполно исто со роботската деинцијализација, оваа функција ги прима референциите кон објектот и ги анулира, затворајќи ја комуникационата врска со камерата.

      \paragraph{Отчитување од Рамка:\\}
        Овој под-инструмент се нарекува и „полиморфски“ инструмент, бидејќи флексибилен е во однос на излезниот сигнал, без било какви промени на влезот. Оваа функција на корсиникот му дозволува да одбери од која „рамка“ отчитува. Под рамка се подразбира вид на информација, односно избира корисникот да оберби бојна, длабинска, инфрацрвена, или „телесна“ слика. Важно е да се спомени дека телесната слика на излез не дава слика, туку низа со димензија $1 \times 6$ чии секој елемент е податок од тип \textit{cluster} кој ги содржи координатите на телото во 3 разни координатни системи - бојна камера (м.е. пиксели), длабинска камера (м.е. пиксели), и вистинската камера (м.е. метри), како и некои други корисни мета-информации

      \paragraph{Отчитување на Зглобни Координати:\\}
        Фунцкијата за отчитување на координатите на самите зглобови ги прима како влез индексот од 0 - 5 на телото и една енумерирана вредност која го претставува самиот зглоб. Иако не се доведува низата што се генерира од отчитувањето на телесната слика, оваа фунцкија сепак има пристап до зглобовите. На излез го дава соодветниот \textit{cluster} на посаканиот зглоб.

    \subsubsection{PS4 контролер модул}
      MakerHub интерфејсот за PS4 контролерот овозможува лесно отчитување на податоци од сите копчиња и оски од PS4 контролер. Функционира според стандардната парадигма на LabVIEW, односно има блок за иницијализација, отчитување и деиницијализација, а има вградена можност за детекција на настани, т.е. промена на состојбата на копчињата.

      \paragraph{Иницијализација:\\}
        Стандарден блок за иницијализација на уред, во овој случај PS4 контролерот. По желба може да се избере дали да се иницијализира првиот конектиран уред, или во случај на повеќе уреди, може да се избере специфичен контролер по автоматски зададен индекс. Како излез од блокот повторно добиваме референции кон објектот, односно контролерот, и сигнал на грешка.

      \paragraph{Деиницијализација:\\}
        Иста функција и влезови како и горенаведените блокови за деиницијализација.

      \paragraph{Отчитување:\\}
        Оваа функција за отчитување има две излезни порти: првата порта има ги дава отчитуваните вредности на копчињата, а втората порта се користи за детекција на промени (\textit{Event Detection}) во состојбата на голем број од влезовите. Оваа порта понатаму се поврзува со \textit{Event Structure} и го поедноставува процесот на интегрирање на контролата во програмата.

  \subsection{Важни под-инструменти и нивна употреба}
  \label{sec:bodydetect}
    %maybe switch модуси with режими
    %get images of the blocks from the Ctrl+H window as well as whole sub-vi screenshots
    \paragraph{bodyDetect:\\}
      Функцијата \textit{bodyDetect} служи за препознавање на човек и има два режими на операција. Првиот режим, наречен \textit{desperate} или \textbf{очаен}, ги дава на излез декартовите координати на првата личност која ќе биде детектирана.

      Вториот режим, наречен \textit{Colour Match} или \textbf{пребарување според боја}, врши избор на личност за следење според анализа бојата на претходно одредена област. Областа, во овој случај, претставува посебен полигон на пиксели што припаѓа на секоја од личностите. Оваа област може да се наоѓа било каде и да има било кој облик; во оваа функција, таа област се наоѓа во горниот дел (градниот кош) на човекот. Се проверува сличноста на овие области со некоја референта боја, и се избира за следење тој човек со најсоодветна обоена област. Анализата на овие области ќе биде подетално покриена во описите за други под-инструменти.

    \paragraph{colourDist:\\}

      Подфункцијата \textit{colourDist} се наоѓа во инструментот за препознавање \textit{bodyDetect} и ја врши анализата на обоените области. Оваа фунцкија исто има два режими на работа со два вида на толеранти полиња на боја. На влез е доведена просечната боја на една област, и функцијата проверува дали оваа просечна боја припаѓа на едно претходно дефинирано толерантно поле, кое се наоѓа во дискретен тридимензионален боен декартов систем (поглавје \ref{sec:colour_theory}). Толерантното поле проверува за сличност според хроматичност (состав на боја), но и е проширено за да прифаќа еден поширок опсег на осветлувања.

      \paragraph{Режим - Толерантен цилиндар:\\}

        Првиот режим на работа поседува толерантно поле во облик на цилиндар, каде што радиусот на цилиндарот претставува „разлика во боен состав“ (односно хроматично отстапување), додека неговата висина го претставува опсегот на прифатени интензитети на осветленост.

        Равенките за пресметка на хроматично отстапување се:
        $$  \norm{\vec{x_t}}^2 = R^2 + G^2 + B^2,$$
        $$  \norm{\vec{v_{ref}}}^2 = R_{ref}^2 + G_{ref}^2 + B_{ref}^2, $$
        $$    (\vec{x_t} \cdot \vec{v_{ref}})^2 = R\ R_{ref} + G\ G_{ref} + B\ B_{ref} $$
        $$    colourDist(\vec{x_t}, \vec{v_{ref}}) = \delta = \sqrt{\norm{\vec{x_t}}^2 - \frac{(\vec{x_t} \cdot \vec{v_{ref}})^2}{\norm{\vec{v_{ref}}}^2}} $$
        \bigbreak

        Додека равенката за осветлувачко отстапување гласи:
        $$ \Delta I = \norm{\vec{x_t}} - \norm{\vec{v_{ref}} ци} $$
        \bigbreak
        Условот за припаѓање на некоја обоена област $i$ е:
        $$ \delta_{i} < C $$
        $$ I_{min}< \Delta I_i < I_{max} $$

        Каде $C$, $I_{min}$, и $I_{max}$ се константи зададени од програмерот.

        Доколку точката што ја претставува бојата (во декартовиот боен систем) припаѓа на овој цилиндар, личноста на која ѝ припаѓа оваа боја е ставена во низата на можни кандидати за следење.

      \paragraph{Режим - Толеранта сфера:\\}

        Вториот режим на работа користи толерантно поле во облик на сфера, каде што нејзиниот волумен ги зафаќа и дозволениот боен состав и интензитет. Се пресметува тридимензионален вектор од просечната боја на доведената област до референтата боја, односно до центарот на сферата. Доколку овој вектор припаѓа целосно во сферата, личноста на која што ѝ припаѓа оваа боја станува кандидат за следење.

        Пресметката за релативниот вектор гласи:
        $$ \vec{V_i^r} = \vec{V_r} - \vec{V_i}= [R_r - R_i, G_r - G_i, B_r - B_i] $$
        Каде $\vec{V_i}$ е векторско прикажување на влезната боја, додека $\vec{V_r}$ е векторското претставување на референтната боја.
        Додека неговата должина (нормата $\norm{\vec{V_i^r}}$ ) се наоѓа со примена на питагорова теорема:
        $$ \norm{\vec{V_i^r}} = \sqrt{{R_i^r}^2 + {G_i^r}^2 + {B_i^r}^2} $$

        По споредување на бојните области на сите детектирани личности, сите кандитати за следење се сублимирани во една низа. Според видот на анализа, се наоѓа најзадоволителната (т.е. минималната) вредност на низата, и личноста на која ѝ припаѓа оваа вредност е избрана за следење. Во случај анализата да била цилиндрична, оваа вредност ќе биде хроматично отстапување, односно близина до оската на цилиндарот, занемарувајќи го осветлувањето. Доколку видот на анализа да бил сферичен, вредноста која се споредува е должината на векторот помеѓу центарот на сферата и влезната боја.

        Како излез на функцијата е индексот на личноста која треба да се следи.

      \paragraph{differentialDrive:\\}
        Блокот differentialDrive всушност го претставува главниот контролер во самиот систем. Тој на влез ги прима поларните координати на детектираната личност и на излез ги дава потребните вредности на брзини што требат да се впишат во моторите за да се постигне саканата положба, односно да конвергираат референтниот и реалниот вектор кон личноста. %we'll discuss the vector and differential drive mathematics in the secion above titled "Upravuvacka Sema"

    \paragraph{Телеоперација:\\}
  \subsection{Образложение на Софтверот}
    Следи изведбата во LabVIEW на етапите на функционирање опишани во поглавје \ref{sec:general_desc}. Програмата се состои од два дела софтвер кои работат паралелно на два соседни машини: персоналниот компјутер (главна процесорска единица) и вградениот sbRIO компјутер на DaNI роботот. На главната единица работат повеќе паралелни \textit{while} рутини, како што се:

    \paragraph{Создаватели на Параметри:\\}
      Три создатели на параметарни пораки работат паралелно, чекајќи да се зададе промена на некој параметар од страна на корисникот и да се стави новата информација на челото на редот за пораки кои ќе се праќат до роботот.
      \begin{figure}[!h]
          \centering
          \includegraphics[width=0.75\linewidth]{./images/gain_message_generator.png}
          \caption{Создател на Пораки - Засилувања}
        \end{figure}
        \begin{figure}[!h]
          \centering
          \includegraphics[width=0.75\linewidth]{./images/setpoint_message_generator.png}
          \caption{Создател на Пораки - Рефентни Вредности}
        \end{figure}
        \begin{figure}[!h]
          \centering
          \includegraphics[width=0.75\linewidth]{./images/robot_stop_generator.png}
          \caption{Создател на Пораки - Запирање на Роботот}
        \end{figure}
      Овие создатели работат во настанска структура (\textit{event structure}), односно само реагираат кога ќе има промена во таа вредност за која се одговорни.

    \paragraph{Создател на движечки наредби:\\}
      Создателот на движечки наредби е главниот дел од програмата, и во зависност од режимот на работа одбран од корисникот, тој функционира на разни начини. Доколку корисникот избере режим на телеоперација, роботот се управува со блутут контролерот како било која друго возило со радио управување. Доколу корисникот избере еден од режимите на автономна работа, роботот ќе ја изврши соодветната функција (поглавје \ref{sec:bodydetect}), при која на излез ќе добие соодветни наредби за движење.
      \begin{figure}[H]
        \centering
        \includegraphics[angle=-90, scale=0.65]{./images/command_generator_true.PNG}
        \caption{Создател на наредби при автономно движење}
      \end{figure}
      Независно од како се добиени овие наредби, наредбите се пакуваат во формата на општата порака и се ставаат на редот за пораки.
      \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\linewidth]{./images/command_generator_false.PNG}
        \caption{Создател на наредби при телеоперација}
      \end{figure}
    \bigbreak
    \paragraph{Раководител на Пораки:\\}
    Сите пораки се ставени во еден ред на податоци, создаден со \textit{Queue} фунцкијата. Секој создател си ги става свои пораки во овој ред. Наредбите за движење се ставаат на крајот на редот, додека другите се сметаат за итни и се ставаат на челото на редот. Структурата за раковедење со пораките има за своја задача да ги отчтува пораките од челото на редот и да ги испраќа преку мрежниот тек (\textit{Network Stream}) до роботот.
    \begin{figure}[H]
      \centering
      \includegraphics[width=0.5\linewidth]{./images/message_handler.png}
      \caption{Раководителот на пораки}
    \end{figure}

    \paragraph{Толкувач на \textit{Bluetooth} Наредби:\\}
      Со употреба на погоре споменатите библиотеки и една настанска структура, се толкуваат податоците од контролерот, како што се промена на режим и итно прекинување на роботот. 


\newpage
%We need to take a look at this whole section, we will still explain what PID is and all that.
\begin{comment}
  \section{Управување со повратна врска}
    \subsection{ПИД контролери}
      \subsubsection{Линеарни закони за управување}
      Линеарните закони за управување претставуваат едни од најстарите и најраспространетите управувачки стратегии. Причината за тоа е фактот што со примена на оваа стратегија можат да се решат дури 90\% од сите управувачки задачи. Исто така, овие техники на подесување на параметри на овие закони за управување се детално разработени и многу едноставни за практична примена.\\
      Линеарните закони за управување се остваруваат со три дејствија:

      \begin{itemize}
				\item Пропорционално (\textit{P})
				\item Интегрално (\textit{I})
				\item Диференцијално (\textit{D})
				\end{itemize}

			Оттука уредот со кој ова управување се реализира се нарекува \textbf{пропорционално-интегрално-диференцијален регулатор} или накратко \textbf{PID}. Законите за управување може да се претстават како:

      $$ u(t) = K_{p}e(t) + \frac{K_{p}}{T_{i}} \int_{0}^{t}{e(\tau)d\tau} + K_{p}T_{d} \frac{de(t)}{dt} $$

      Од каде преносната функција на PID e:

			$$ G(s) = K_{p}(1+\frac{1}{T_{iS}}+T_{d}S) $$

			Однесувањето на системот управуван од PID контролерот зависи од изборот на параметри кои го дефинираат интензитетот на секое од трите дејства. Без разлика од типот на регулаторот или неговата реализација, основните барања за регулација на системот се стабилноста, точноста и брзината на одзивот. Поради тоа, од голема важно е да се разгледа ефектот на секое од овие дејства на системот поединечно.

			\begin{figure}[H]
				\includegraphics[width=0.5\linewidth]{./images/li_za_up.png}
				\centering
				\caption{Линеарни закони за управување}
				\label{fig:li_za_up.png}
				\end{figure}

        \subsubsection{Пропорционално дејство}
      Пропорционалното дејство ја одредува големината на статичката грешка во системот. Со негово зголемување, грешката се намалува. Меѓутоа во зависност од типот на системот кој се управува, зголемувањето на Кр може да доведе до нестабилен систем (сл.\ref{fig:el_2.png}). Во секој случај, бидејќи постоењето на статична грешка зависи од редот на \textit{астатизмот} (својсво на систем, при константен влез во стационарна состојба, да дава променлив излез) на повратната преносна функција, пропорционалниот коефициент на дејство не може да го промени типот на статичка грешка, туку само нејзината големина. Потребно е да се внимава на фактот дека кај пропорционалното управување нулта статичка грешка имплицира и нулто управување, а тоа значи и прекин на било какви активности во процесот.
			Кај некои системи можно е и посакуваниот перформанс да се оствари исклучиво со помош на ова дејство така што управувањето се реализира исклучиво со пропорционален регулатор.
			Пропорционалниот регулатор е наједноставен тип на регулатор кој што се опишува со равенката $ u(t) = K_{p}e(t) $ каде што $ K_{p} $ претставува фактор на пропорционално дејство или појачување на регулаторот а $ e(t) $ e грешка на сигнал. Секој пропорционален регулатор се одликува со својата пропорционалност која се дефинира како потребна процентуална промена на влезот, така што излезот би се променил за 100\%. Пропорционалнотото подрачје може да се дефинира како реципрочна вредност од факторот на појачување иразена во проценти. Со појачување на факторот $ K_{p} $, односно намалување на пропорционалното подрачје, константноо се отстапува управувањето на променливата од нејзината зададена вредност, т.е таа се намалува. Во исто време се зголемува брзината на реагирање. На слика \ref{fig:el_3.png} е прикажано дејствувањето на Р регулаторот ако на неговиот влез се додаде грешка на сигнал во облик на отскочна функција.

			\begin{figure}[H]
				\includegraphics[width=0.3\linewidth]{./images/el_2.png}
				\centering
				\caption{Отскочен одзив при промена на пропорционален коефициент}
				\label{fig:el_2.png}
				\end{figure}

			\begin{figure}[H]
				\includegraphics[width=0.3\linewidth]{./images/el_3.png}
				\centering
				\caption{Дејствување на P регулатор}
				\label{fig:el_3.png}
				\end{figure}

        \subsubsection{Интегрално дејство}
      Интегралното дејство има особина да при нулти влез во интеграторот, на излез да добие константен сигнал. Од тука, интегралното дејство во одредена смисла го исправи недостатокот на пропорционалното дејство, односно се додека постои грешка, колку и да е таа мала излезот од интеграторот ќе се менува, а со тоа и самиот сигнал на управување. I регулаторот се опишува со равенката $ u(t) = K_{i}\int_{0}^{t}{e(t)dt} $ која пропорционално ја врзува грешката $ e(t) $ со брзината на управувачка променлива $ u(t) $. Реципрочната вредност на појaчувањето $K_{i}$ е константата $T_{i}$ и претставува време на интегралното дејство $K{i}=\frac{1}{T_{i}}$. Главен недостаток на овој тип на регулатор е дестабилизацијата на системот проследено со за него својственото каснење. На слика \ref{fig:el_5.png} е прикажано делувањето на интегралниот регулатор, ако за влез се донесе грешка $e(t)$ во облик на единечна отскочна функција.

			Промената на побуда на системот ќе резултира во промена на одзивот на сигналот кој ќе се (при услов да е системот правилно проектиран), ќе се приближува до зададен референтен сигнал.

			Потребно е да се истакне дека оваа особина на интеграторот е многу корисна кај системи чии извршни органи имаат мртва зона која престанува да реагира на побуди.

			Грешката акумулирана низ интеграторот ќе го одржува нивото на побуда на извршниот орган надвор од мртвата зона се додека одзивот на системот не се изедначи со референцата.

			\begin{figure}[H]
				\includegraphics[width=0.3\linewidth]{./images/el_4.png}
				\centering
				\caption{Отскочен одзив при промена на интегрален коефициент}
				\label{fig:el_4.png}
				\end{figure}

			\begin{figure}[H]
				\includegraphics[width=0.3\linewidth]{./images/el_5.png}
				\centering
				\caption{Дејствување на И регулатор}
				\label{fig:el_5.png}
				\end{figure}

			Примената на интегралното дејство доведува до успорување на одзивот и во однос на пропорционалното дејство. Причина за таквото однесување е тоа што при нагла промена на сигналот, грешката на излезот на интегрсторот расте многу поспоро од излеот на појачување кај пропорционалното управување. Меѓутоа по некое извесно време, излезот на интеграторот, кој всушност го акумулира, односно собира сите претходни вредности на грешката, значајно се зголемува со што се добива осцилаторно однесување на одзивот.

			За да се избегне успорувањето на одзивот при промена на сигнал, интегралното дејство никогаш не се користи само, туку исклучиво во комбинација со пропорционалното дејство како PI регулатор. Со подесување на P и I дејството на системот може да постигне извесно подобрување на одзивот на системот, при што се прави ‘компромис‘ помеѓу брзината на одзивот и големината на прескокот. Управување со PI регулаторот е опишано со следната равенка $u(t) = K_{p}e(t)+K_{i}\int_{0}^{t}{e(t)dt}$. Ако на влезот на PI регулаторот се појави сигнал во облик на отскочна функција, пропорционалниот член ќе постави излез $u(t)$ на вредност $K_{p}$, а под дејство на интегралниот член, $u(t)$ ќе продолжи да расте и во моментот $T_{i}$ вредноста на излезот ќе биде еднаква на $2K_{p} = 2(K_{i}T_{i})$. Со други зборови, времето потребно за интеграција е времето потребно а излезот под дејство на интегралниот член, да ја промени вредноста добиена со пропорционалниот член (слика \ref{fig:el_6.png} и слика \ref{fig:el_7.png})

			При посакувана брзина на одзивот, прескокот може да се намали само со воведување на диференцијално дејство.

			\begin{figure}[H]
				\includegraphics[width=0.3\linewidth]{./images/el_6.png}
				\centering
				\caption{Отскочен одзив при ПИ и ПИД регулатори}
				\label{fig:el_6.png}
				\end{figure}

			\begin{figure}[H]
				\includegraphics[width=0.3\linewidth]{./images/el_5.png}
				\centering
				\caption{Дејствување на ПИ регулатор}
				\label{fig:el_7.png}
				\end{figure}
        \subsubsection{Диференцијално дејство}
      Диференцијалниот регулатор се опишува со равенката $u(t) = K_d\frac{de(t)}{dt}$.
			Самостојното постоење на диференцијалниот регулатор нема многу смисла, бидејќи кога сигналот на грешка е константен, изводот на овој сигнал е нула. Диференцијалниот регулатор реагира само на брзи промени, додека спорите и долготрајни промени не би предизвикале никакво дејство на овој регулатор. Диференцијлното дејство води сметка за промена на брзината на грешката на сигналот. Доколку не сакаме да имаме прескок во одзивот, неопходно е системот да ‘кочи‘, односно да се успорува промената на одзивот кога грешката на сигналот ќе се намали.

			Очигледно е дека изводот на грешката впрочем ја дава потребната информација за брзинста и смерот на промена на грешка на сигналот.Имајќи во предвид да секој процес има одредена динамика, потребно е некое време да пројде пред да се приметат ефектите од промена на сигналот. Диференцијалното дејство може да се интегрира и како еден вид на предвидувач на грешка на сигнал (слика \ref{fig:el_8.png}). Во пракса диференцијалното дејство покажува значајни недостатоци кои потекнуваат од мерниот шум на излезот.

			Често користен, а воедно и применет во нашиот проект е пропорционално-диференцијалниот генератор односно PD. PD регулаторот опишан со следната равенка: $u(t)=K_{p}e(t)+K_{d}\frac{de(t)}{dt}$. Бидејќи станува збор за диференцијално дејство, ќе набљудуваме пореметување $e(t)$ во облик на нагибна функција. Ако на влезот на PD регулаторот доведеме нагибен сигнал $u(t)$ под дејство на пропорционалниот член, сигналот ќе се промени за вредност $K_{d}$ за кој во почетокот скоковито се сменил под дејство на диференцијалниот член. Со други зборови, по време $T_{d}$ вредноста $u(t)$ ќе биде $2K_{d} (за почетни услови t=0 и (t)=K_{d}$, што ја дава врската помеѓу $K_{p}$ и $K_{d}$ односно $K_{d}=K_{p}T_{d}\rightarrow K_{p}=\frac{K_{d}}{T_{d}}$. Конечно почетниот израз може да се запише како $u(t)=K_{p}(e(t)+T_{d}\frac{de(t)}{dt}$.

			Бидејќи со PD управувањето не може да се дефинира основна отскочна промена на грешка (изводот е еднаков на бескрај), од горе наведеното се користи линеарна промена на грешка $e(t) = E\star t$. Тогаш управувачкиот закон на PD регулаторот има облик $u(t) = K_{p}E(t+T_{d})$. Од оваа равенка се гледа дека за грешка $e(t)=Et_{0}$ во момент $t_{0}$, управувачката променлива пропорционална со $E(t+T_{d}$, односно со грешка во момент $(t+T_{d})$. Значи, постои ефект на поместување на управувачкиот сигнал напред во време за износ $T_{d}$. Константата $T_{d}$ се дефинира како временски интервала за кој диференцијалното дејство оди напред во однос на пропорционалното дејство, проследено со линеарна промена на грешка.

			\begin{figure}[H]
				\includegraphics[width=0.3\linewidth]{./images/el_8.png}
				\centering
				\caption{Диференцијално дејство како предвидувач на грешка}
				\label{fig:el_8.png}
				\end{figure}

			\begin{figure}[H]
				\includegraphics[width=0.3\linewidth]{./images/el_9.png}
				\centering
				\caption{Дејствување на ПД регулатор}
				\label{fig:el_9.png}
				\end{figure}

        %DO WE STILL NEED THIS?
        \subsubsection{ПИД контролери во LabVIEW}
      Прикажан подолу во сл.\ref{fig:PIDBlock.png} е блокот за ПИД контролер од Real Time модулот на LabVIEW. Првиот влез од левата страна е портата за грешка што функционира исто како и сите други кои досега се спомнати. Во следниот влез, наречен setpoint, се доведува референтната вредност кон која се стремиме, додека во process variable ја доведуваме големината која што ја управуваме. Следните 3 влезови одговараат на коефициентите на ПИД управувањето, односно пропорционалниот, интегралниот, и диференцијалниот коефициент соодветно.

			Од десната страна имаме излез на грешката и излезот што одговара на самата управувана вредност.

			\begin{figure}[H]
				\includegraphics[width=0.3\linewidth]{./images/PIDBlock.png}
				\centering
				\caption{LabVIEW ПИД Блок}
				\label{fig:PIDBlock.png}
				\end{figure}

        \newpage
\end{comment}

\medskip
\nocite{*}
\printbibliography[heading=bibintoc,title={Користена литература}]

\end{document}
